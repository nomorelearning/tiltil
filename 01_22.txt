목차
[1. 함수
 2. 매개변수와 인자
 3. 재귀 함수
 4. 매장 함수
 5. 함수와 Scope
 6. 함수 스타일 가이드
 7. Packing & Unpacking
 8. 참고]

1. 함수: 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
    - 함수 사용 이유: 코드 중복 방지, 재사용성 증가, 코드의 가독성과 유지보수성 향상
    - 함수 호출: 함수를 실행하기 위해 함수 이름을 사용해 해당 함수의 코드 블록을 실행하는 것
    1. 함수 구조 (이미지 참고)
        - def function(parameter; 매개변수): 함수; return value(return 문이 없으면 None 반환)
        - Docstring: 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
    2. 함수와 반환값
        - print() 함수는 반환값이 없다. just 출력을 담당. return = print(1) ; print(return) # None

2. 매개변수와 인자★
    - parameter(x, y)'정의'할 때 매개변수, argument(인자(a, b); 함수 '호출' 시 실제로 전달되는 값)
    1. 다양한 인자 종류(인자를 어떻게 받을 것이냐냐)
        1. 위치 인자: 함수 호출 시 인자의 위치에 따라 전달되는 인자; 위치인자는 함수 호출 시 반드시 값을 모두 전달해야 함
            - greet(25, 'Alice'), greet('Alice')(x)
        2. 기본 인자 값: 함수 정의에서 매개변수에 기본값 할당(name, age = 30) ; 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당
        3. 키워드 인자: 함수 호출 시 (name = 'Dave', age = 35) ; 호출 시 키워드 인자는 위치 인자 뒤에 위치(greet(age= 35, 'Dave')(x))
        4. 임의의 인자 목록: 정해지지 않은 개수의 인자를 처리하는 인자, 매개 변수 앞에 *, 여러 인자를 튜플로 처리 ; 에스터리스크
        5. 임의의 키워드 인자 목록: 정해지지 않은 개수의 키워드 인자를 처리하는 인자, 매개 변수 앞에 ** 붙여, 여러 인자를 dict로 묶어 처리
            - print_info(name = 'dave', age = 25) # {'name' : 'dave', 'age' = 25}
        함수인자 권장 작성순서: def func(pos1, pos2, default_arg='default', *arge, **kwargs): ..(위치>기본>가변>가변 키워드)

3. 재귀 함수: '함수 내부에서 자기 자신을 호출하는 함수' ; 종료조건이 있어야 함★
    - 팩토리얼: def fac(n): if n == 0: return 1 ; else: return n * factorial(n-1)
    - 특정 알고리즘 식을 표형할 때 변수 사용 줄고, 가독성 높아짐
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성
    - 사용하는 이유: 문제 자연스러운 표현, 코드 간결성, 수학적 문제 해결

4. 내장 함수: 기본 제공 함수(built-in) (외장함수라는 명칭은 없음)
    1. 유용한 내장 함수 map & zip
        - map(function, iterable): 첫번째 인자로 함수를 받음, iterable: 반복이 가능한 객체
            * 리스트의 모든 요소에 함수를 적용
            * 실행은 안되는데, 미리 준비해놓는 함수수
        - zip(*iterable): '임의의' iterable을 모아 튜플을 원소로 하는 zip object를 반환
            * 여러 리스트 동시에 조회할 때, 2차원 리스트의 값은 칼럼(열) 요소를 동시에 조회할 때
            * 개수가 맞지 않으면 초과하는 인자들은 컷

5. 함수와 Scope: 함수는 코드 내부에 local scope를 생성, 그 외는 global scope로
    - scope: global scope(코드 어디서든 참조할 수 있는 공간), local scope(함수가 만든, 함수 내부에서만 참조 가능)
    - variable: global variable(global scope에 정의된 변수), local variable(~)
    - local scope에 존재하는 변수 ~ 변수의 수명주기
        * built-in scope(영원), global scope(모듈호출~인터프리터 끝), local scope(함수호출~함수종료;글로벌까지 살아남지 못함함)
        * 함수 내에서는 바깥 scope 변수에 접근 가능하나 '수정은 불가'
        * LEGB Rule: Local > Enclosed > Global > Built-in(이 순서대로 이름 찾을 수 있음; 로컬이 가장 작은 범위), 역순으로 이름 찾음(sum 예시)
        * "호출이 될 때 실행된다고 생각!!" + 매개변수와 변수의 이름 간 헷갈리지 않기
    1. global 키워드: 변수의 스코프를 전역 범위를 지정하기 위해, 일반적으로 함수 내에서 전역 변수를 수정하는 경우
        - 매개변수에는 global 키워드 사용 불가
        * global 선언 후 참조 가능

6. 함수 스타일 가이드
    1. 함수 이름 작성 규칙
        - 소문자와 언더스코어, 동사로 시작하여 함수의 동작 설명, 약어 사용 지양
        - 함수 이름 구성 요소
            * 동사_명사(), 동사_형용사_명사(), get/set접두사_명사(); get은 값을 얻어내는 동작, set은 세팅
    2. 단일 책임 원칙(함수 설계에 대해): 모든 객체는 하나의 '명확한 목적'과 '책임'만 가져야 + 유지보수성
        - 올바른 설계와 명시도가 높은 코드!

7. Packing & Unpacking
    1. Packing: 여러개의 값을 하나의 변수에 묶어서 담는 것
        - *변수명(매개변수): 나머지 모든 값을 튜플로(언제는 리스트) '묶어서'
        - print()는 위치 인자가 없는 함수(only 가변 인자)
    2. Unpacking: 패킹된 변수 풀어서, 개별 변수나 함수 인자로 전달
        - 시퀀스를 함수에 전달할 때..names = ['a','b','c']; my_function(*names)
        - my_dict = {'x':1,'y':2,'z':3}; my_function(**my_dict)
            딕셔너리 키-값 쌍을 개별 키워드 인자로 전달

    - *, ** 패킹/언패킹 정리
        *)  패킹 연산자로 사용될 때, 여러 개의 인자를 하나의 리스트나 튜플로 묶음
            언패킹 연산자로 사용될 때, 시퀀스나 반복 가능한 객체를 각각의 요소로 언패킹하여 함수의 인자로 전달
        **) 언패킹 연산자로 사용될 때, 딕셔너리의 키-값 쌍을 개별 키워드 인자로 전달

8. 참고
    - 람다 표현식: 익명 함수를 만드는 데 사용되는 표형식(한줄로만 간단 함수 정의), 호출할 수가 없음
        * lambda 매개변수: 표현식, map에서 함수 인자로 넣는 경우 많이 사용됨, 1회성 함수일 때..
        - 라이브러리 활용성을 높이고 유연하게 쓰이도록록

    - my_func = print_hello : 함수 복사. 함수도 객체처럼 복사 및 호출이 가능하구나! 예: f(이게 호출이 되나?)
    - lst = [('홍길동',22), ('권예경', 26), ('문빈', 20)]
        sorted(lst, key = lambda x: x[1]) # 나이순으로 정렬
    - input().split(): 문자열로 받기