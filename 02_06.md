[어제 이야기 복습
버블 정렬: 끝에서부터 대상 위치 정하기,, 비교 대상은 왼쪽부터 순차
뷰 믄제: 가운데 기준]

1. 카운팅 정렬
  - 항목들의 순서를 결정하기 위해 집합에 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
  - 제한사항: 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능, 카운트를 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야
  - 시간 복잡도: O(n+k): n은 리스트 길이 k는 정수의 최댓값 .. n이 1,000,000개 이내인 정도에서 사용
  - 방법
    1단계) 각 항목들의 발생 횟수를 세고 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다.
        # COUNTS의 크기는 max(n) + 1(인덱스로 접근하기 때문, 0부터 있어야지)
    2단계) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정; 값을 계단식으로..
    3단계) DATA 값의 인덱스를 통해 COUNTS의 값을 인덱스로 삼는 TEMP에 DATA 값을 넣기(끝에서부터)
          넣고 COUNTS 값을 하나 감소
      -> 원래 같은 값끼리에서 있던 우선순위를 반영하기 위해서(stable) 3단계를 끝에서부터 시작

2. 완전검색 ; Brute-force, generate-and-test기법
  - 문제의 해법으로 생각할 수 있는 "모든 경우의 수"를 나열해보고 확인 -> 일반적으로 경우의 수가 작을 때 유용
  - 수행속도 느림, 해답 찾지 못할 확률 작음.. 코테에서 우선 완전검색을 접근해 도출하고 성능 개선하는 방향
  - Baby-gin Game: run과 triplet 그리고 baby-gin의 정의
    * 고려할 수 있는 모든 경우의 수 생성 > 해답 테스트
  - 순열을 어떻게 생성할 것인가: 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
3. 그리디
  - 최적해를 구하는 데 사용되는 근시안적인 방법, but 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만 최종적인 해답도 최적이라는 보장은 없다 -> 조심스럽게 사용하라
  - 과정
    1단계) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가
    2단계) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지 확인. 문제의 제약조건을 위반치 않는지 검사
    3단계) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지 확인, 아직 전체 해가 완성치 않았으면 1단계로
  - sort 해놓고, 3이상이니? 1이상이니? 그렇다면 옆, 옆옆도 1이상이니?
  - 9까지 인덱스 만드는 것이 아니라 11까지인 이유? 굳이 if문 하나 더 만들기 싫어

* 디버거를 사용하면 선택 지점 직전까지의 동작 기록들을 볼 수 있음