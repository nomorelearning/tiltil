데이터 구조 활용: 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능 활용하기
'호출'이라고 하면 '함수'
클래스는 타입을 표현하는 방법, 정해주는 주체
클래스는 파이썬에서 '타입을 표현하는 방법'
메서드: 클래스에 정의된 함수; 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재(객체가 호출해주는 함수)

함수와 메서드의 차이?
함수 호출: add(1,2)
메서드 호출: a = Calculator() ; a.add(1, 2) ; a는 데이터타입객체, add는 메서드
append는 list 클래스가 가지는 메서드

문자열 조회/탐색 메서드
s.find(x): x의 첫번째 위치를 반환, 없으면 -1
s.index(x): x의 첫번째 위치를 반환, 없으면 오류
s.isupper(): 문자열 내의 모든 문자가 대문자인지 확인          ---> is로 시작하는 메서드들은 반환값이 Boolean일 가능성 높음
s.islower(): 문자열 내의 모든 문자가 소문자인지 확인
s.isalpha(): 문자열 내의 모든 문자가 알파벳인지 확인(유니코드상 Letter)

문자열 조작 메서드("새"문자열 반환)
s.replace(old, new[,count]): 바꿀 대상 글자를 새로운 글자로 바꿔서 반환, count는 바꿀 갯수
s.strip([chars]): 공백이나 특정 문자를 제거
s.split(sep = None, maxsplit = -1): sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환
'separator'.join(iterable): iterable이 문자열을 연결한 문자열을 반환

------------------------------------------------------

리스트 값 추가 및 삭제 메서드
L.append(x): 리스트 마지막에 항목 x를 추가 "원본이 바뀐다"  print(list.append(x)) 는 None
L.extend(m): iterable m의 모든 항목들을 리스트 끝에 추가(+=과 같은 기능)
L.pop(): 리스트 가장 오른쪽에 있는 항목(마지막)을 제거 후 "반환"
★L.pop(x): 리스트의 인덱스 i에 있는 항목을 제거 후 "반환"
L.insert(i, x): 리스트의 지정한 인덱스 i 위치에 항목 x를 삽입
L.remove(x): 리스트에서 첫번째로 일치하는 항목을 삭제
L.clear(): 리스트의 모든 항목을 삭제

리스트 탐색 및 정렬 메서드
L.reverse(): 리스트의 순서를 역순으로 변경
L.sort(): 리스트를 정렬(매개변수 이용가능): 기본은 오름차순
L.index(x): 리스트에서 첫x의 인덱스 반환
L.count(x): 리스트에서 x의 개수를 반환

# help를 보면, 리턴값이 있는 메서드들은 return이 명시되어 있음
# 공식문서에서 검색해보면 정확하게 다 나오겠지? (라이브러리 레퍼런스, 언어 레퍼런스) ; 가벼운 마음

--------------------------------------------------------

복사
가변/불변 객체 개념
가변(mutable)객체: 생성 후 내용을 변경할 수 있는 객체(리스트, 딕셔너리, 집합)
b = a: 복사가 아닌 같은 주소를 할당 -> 운명 공동체
불변(immutable)객체: 생성 후 변경 불가(정수, 실수, 문자열, 튜플)
b = a: 복사임. 그냥 값을 재할당 하는 것임
변수는 메모리 주소를 저장 -> 여러 변수가 동일한 객체를 참조할 수 있음

얕은 복사
객체의 최상위 요소만 새로운 메모리에 복사하는 방법(내부에 중첩된 객체가 있다면 그 객체의 참조만 복사됨;새로운 메모리 x; 운명공동체)
리스트 슬라이싱, copy(), list()
깊은 복사: 객체의 '모든 수준의 요소'를 '새로운 메모리'에 복사하는 방법, 중첩된 객체까지 모두 새로운 객체로 생성됨

해싱, 해시테이블? 해시 함수를 사용해 변환한 값을 인덱스로 삼아 키와 벨류를 저장하는 자료구조(빠른 저장과 검색)
- 키를 해시 함수를 통해 해시값으로 변환, 변환된 해시값을 인덱스로 삼아 데이터 저장 및 찾음 => 검색 삽입 삭제 빨라짐
"검색" 알고리즘이 중요
직접번지(키로 바로 인덱스 맵핑; 키가 정수라면; 연속적인 메모리 공간에 저장한다; 범위가 정해져야)
간접번지
"해시어블": 딕셔너리 키로 쓸 수 있는 것(immutable) -- int, String,, float, tuple(내부에 불변만 있을 경우)
동일 키는 동일 위치로 가정하고 빠른 검색을 수행; 매번 할 때마다 다른 값은 안돼! 가변형 안됨됨
---------------------------------------------------------

비시퀀스 데이터(set, dict)
1) dict: 고유한 항목들의 정렬되지 않은 컬렉션
  - 인덱스 대신 키를 사용: 키값을 가지고 값을 호출할 때 메서드 get을 사용
  - get(k[, v]): v는 키의 값이 없다면 넣을 값
  - keys(), values(), items(): 유사 리스트 형식으로 출력, items는 (키,밸류) 튜플로
  - pop(k[, v]): 없으면 v
  - setdefault(k[, v]): 딕셔너리에서 키 k와 연결된 값 반환(딕셔너리에 바로 추가)
  - update(others): 다른 딕셔너리 혹은 키워드 인자 형태로,, 갱신(덮어씀 혹은 추가)

2) set: value 없이 key값만 저장한다고 생각 (빈 셋 만들기 = set())
  - 검색을 위해서 발전
  - add(x): x가 이미 있다면 변화 없음
  - remove(x): x 제거, 없으면 에러
  - pop()은 임의의 항목 반환
  - discard(x): x 제거, 없어도 에러 안남
  - update(iterable): 세트에 다른 iterable 요소 추가
  - 세트 집합 메서드: difference(-), interection(&), issubset(<=), issuperset(>=), union(|)

예외처리: try ; except Exception as e: print(e)
메서드 체이닝: 여러 메서드를 연속해서 호출
앞에가 반환값을 주는 메서드여야 함 ; None을 반환하는 메서드 체이닝은 불가능

논리연산자에서 &&(and), ||(or)


** 기본 기능 **
생성, 수정, 추가, 삭제, 검색, 읽기 ,, 를 각 형태별로 어떻게 진행하지?