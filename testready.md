1 알고리즘: 유한한 단계를 통해 "문제를 해결하기 위한 절차나 방법"이다. 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함.
문해절방단

2 알고리즘을 표현하는 방법 두 가지 의순
- 의사코드
- 순서도

3 좋은 알고리즘? 5정작메단최
정확성, 작업량(적은 연산), 메모리 사용량, 단순성, 최적성(개선할 여지 없이?)

4 알고리즘 성능
- 작업량 표현: 시간 복잡도(실제 걸리는 시간, 실행되는 명령문의 개수)
    빅오 표기법 : 시간 복잡도 한수 중 가장 영향력 큰 n에 대한 항만을 표시(계수는 생략)

5 배열: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용(arr = [1,2,3,4,5])
배열의 필요성 : 하나의 선언을 통해, 둘 이상의 변수를 선언할 수 있어 효율적

6 정렬 : 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 반대 순서대로 재배열 하는 것
종류 : 카운팅, 버블, 선택, 퀵, 삽입, 병합

7 버블 정렬: 인접한 두 원소를 비교하며 자리를 계속 교환             인접, 첫 인 막까지(큰 원소 마지막으로)
- 정렬 과정
    1) 첫 번째 원소부터 인접한 원소끼리 계쏙 자리를 교환하며 맨 마지막 자리까지 이동
    2) 한 단계 끝나면 가장 큰 원소가 마지막 자리로 정렬
- 시간 복잡도 : O(n^2)

8 카운팅 정렬: 항목들의 순서를 결정하기 위해 각 항목이 몇 개씩 있는지 세어 선형 시간에 정렬하는 알고리즘
- 제한사항: 정수나 정수로 표현할 수 있는 자료, 발생 회수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문(카운트들을 위해 집합 최댓값을 알아야)
- 시간 복잡도 : O(n+k)  ; n은 리스트 길이, k는 최댓값
- 정렬 과정
    1) data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
    2) 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 누적합으로 카운드 원소 조정
    3) 카운트 배열에 원소를 1 감소시키고, temp의 해당 인덱스에 항목 저장 .. 반복

9 완전 검색 ; 브루트포스 ; generate-and-test
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- 베이비진 게임
- 느리지만 확실히 답을 줌

10 순열 : 서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열 .. 팩토리얼

11 그리디 : 최적해를 구하는 데 사용되는 근시안적인 방법 => 최종적인 해답이 최적이라는 보장은 없다
 - 동작 과정
    1) 해 선택: 현재 상태에서 부분 문제의 최적해 구하여, 이를 부분해 집합에 추가
    2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지 확인(제약조건 확인)
    3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인
    .. 전체 문제의 해가 완성될 때까지 1부터 반복


################## List ##################

1 2차원 배열 : 1차원 리스트를 묶어놓은 리스트 ; 데이터 초기화로 변수선언과 초기화
- 접근: 행 우선, 열 우선, 지그재그

2 델타(d, 변화율)를 이용한 2차원 배열 탐색
di[] <- [0,1,0,-1] ; dj <- [1,0,-1,0]
for i : 0 -> N-1: for j : 0 -> N-1:
for d in range(4): ni <- i+di[k] ; nj <- j + dj[k] ; if 유효 인덱스면,

3 전치 행렬 : if i < j: arr[i][j], arr[j][i] 교환

4 부분 집합 합
arr = [3,6,7,1,5,4]
n = len(arr)
for i in range(1<<n):
    for j in range(N):
        if i & (1<<j):
            print(arr[j], end=",")
    print()
print()

5 검색 : 저장되어 있는 자료 중 원하는 항목을 찾는 작업
- 탐색 키: 자료를 구별하여 인식할 수 있는 키
- 종류 : 순차 탐색, 이진 탐색, 해쉬

6 순차 검색 : 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 가장 간단하고 직관적, 순차구조로 구현된 자료구조에서 유용, 검색 대상이 많으면 수행시간 증가
- 정렬되어 있지 않은 경우
    검색 과정: 첫 번째 원소부터 있는지 비교, 찾으면 인덱스 반환
- 정렬되어 있는 경우
    검색 과정(오름차순 정렬 경우) : 순차적으로 비교, 키값이 대상 값보다 크면 종료

7 이진 탐색 : 자료의 가운데 있는 키 값과 비교하여 다음 검색 위치 결정.. 반복
- 정렬된 자료에서만 가능
- 검색 과정
    1) 자료 중앙에 있는 원소를 고름
    2) 중앙 원소의 값과 찾고자 하는 목표값을 비교
    3) 목표값이 중앙값보다 작으면 왼쪽반 새로, 크다면 오른반 새로
    4) 반복
- 구현: 시작점, 종료점 이용 ..

8 인덱스 : 데이터 베이스에서 유래, 데이블에 대한 동작 속도를 높여주는 자료구조를 일컫는다
- 인덱스 저장에 필요한 디스크 공간은 보통 테이블 저장에 필요한 디스크 공간보다 작음. 인덱스는 키-필드만 갖고 있기 때문
- 이진 탐색 트리 구조로 되어 있음

9 선택 정렬 : 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환(오름차순 경우)
- 정렬 과정 : 최소값 찾기 > 맨 앞 값과 교환 > 맨 처음 제외한 나머지 리스트에 반복
- 시간 복잡도 : O(n^2)
- 셀렉션 알고리즘 : 저장되어 이쓴ㄴ 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법

################## String ##################
1 문자의 표현
- 네트워크가 발전되기 전 미국 각 지역별 코드체계..> 네트워크 발전하며 정보 해석이 달라지는 문제가 생김
    > 표준안을 만듦(ASCII : 문자 인코딩 표준) -> 확장 아스키는 표현 문자가 많아짐 하지만 해독할 수 있도록 설계해야만 함
    > 전 세계로 인터넷이 확장되며 다국어 처리 표준 만듦(유니코드)
- 유니코드 캐릭터셋으로 분류 ; UCS-2, UCS-4 > 유니코드 인코딩(UTF)

2 문자열
- 자바 : 객체 메타 데이터 + hash + count(길이), offset(시작점), value(참조)
    문자열 데이터 저장, 처리해주는 클래스를 제공
- C : 문자열은 문자들을 배열 형태로 구현된 응용 자료형(마지막에 끝을 표시하는 널문자\0를 넣어야)
- 파이썬 : char타입 없음, 통일된 텍스트 데이터의 취급방법, 문자열 기호('+','*')
    문자열은 시퀀스 자료형 => 인덱싱, 슬라이싱 연산 사용 가능

3 문자열 뒤집기
- 자기 문자열에서 뒤집기 : swap을 위한 임시변수 필요, 반복수행을 반만
s[::-1] // list > reverse > ''.join(s)
- 새로운 빈 문자열을 만들어 소스 뒤에서부터 읽어 타겟에 쓰는 방법

4 문자열 비교 ; c stramp(), java equals(), python '==', is

5 문자열 숫자를 정수로 변환 ; c atoi(), itoa() // java Integer.parseInt(String), toString()
    python int(), float(), str(), repr(), int()

6 패턴매칭; 고지식한, 카프라빈, kmp, 보이어무어
- 고지식한(brute force): 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식
    t-n-i : p-m-j
    시간 복잡도: O(MN)
- KMP 알고리즘: 불일치가 발생한 앞 부분에 어떤 문자가 있는지 미리 알고 있으니, 다시 비교 않고 매칭 수행
    패턴을 전처리해 배열 next[M]을 구하여 잘못된 시작을 최소화
    시간 복잡도: O(M+N)
- 보이어무어: 오른쪽에서 왼쪽으로, 대부분 상용솝웨가 채택
    오른쪽 끝 문자가 불일치하고 패턴 내에 존재하지 않는 경우: 패턴의 길이만큼 이동
    오른쪽 끝 문자 불일치라고 패턴 내에 존재하는 경우: 이전 동일 문자와 차이만큼 점프
    앞 두 알고리즘들의 공통점은 문자열의 문자를 적어도 한번씩 훑는다는 것, 최선의 경우 오메가n
    but 보이어무어는 다 안봐도 됨 : 발상의 전환(오른쪽부터 비교)
    수행시간 : 최악 세타 mn, 일반적으로 세타n보다 시간 덜 듬
    