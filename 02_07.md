1. ★ 2차원 배열
    - 2차원 배열의 선언: 1차원 리스트 묶은 리스트, 2차원 이산의 다차원은 차원에 따라 인덱스를 선언
      세로길이(행의 개수), 가로 길이(열의 개수)를 필요로 함 * arr = [[1,2,3,4], [5,6,7,8]]은 2행 4열!
      -> 파이썬에서는 데이터 초기화를 통해 변수 선언과 초기화가 가능
    - N = int(input()) ; arr = [list(map(int,input().split())) for _ in range(N)]
                         arr = [list(map(int,input())) for _ in range(N)]
    - [[0] * n for _ in range(n)] == [[0 for _ in range(n)] for _ in range(n)]
    - 배열 순회: 모든 원소를 빠짐없이 조사하는 방법
      * 행 우선 조회: for i ~: for j ~: f(array[i][j])
      * 열 우선 조회: for j ~: for i ~: f(array[i][j])
        ex) max_v = 0 ; for i in ~: row_s = 0 ; for j in ~ : row_s += arr[i][j] ; if문으로 row_s와 max_v 비교
        + 홀수 짝수는 (i % 2) * (홀수일 경우 함수) 로 지정할 수도 있음
2. ★ 델타
    - 델타를 이용한 2차원 배열 탐색: 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
    - 인덱스 (i, j)인 칸의 상하좌우 칸 (ni, nj); (0,1,0,-1), (1,0,-1,0)
      == 'di, dj = [0, 1], [1, 0], [0, -1], [-1, 0]'
    - 델타 응용)
      for i in range(N):
          for j in range(M):
              s = arr[i][j]
              for dir in range(4):
                  for c in range(1, k+1):
                      ni = i + di[dir] * c, nj = j + dj[dir] * c
                      if 0<= ni < N and 0 <= nj < M:
                          f(arr[ni][nj])

    - 전치 행렬) arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    - 홀수인 경우) 가운데를 빼야 함.  -= arr[N//2][N//2] * (N%2) 

3. 부분집합
    - 부분집합 합 문제: 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
    - 1<<n: n개의 원소의 개수를 가진 집합의 부분집합 수(2진수를 생각하면 쉬움): 이진수을 한칸씩 밀면 2를 곱하는 것임.. 유레카
      부분집합의 모든 원소들을 순회하며 0인지 1인지 관찰 > 1인 경우 프린트하여 부분 집합의 구성 원소를 가시화
4. 검색
    - 비트: 같은 열을 가진 애들 끼리만 연산을 진행함
5. 이진 검색
6. 선택 정렬
7. 셀렉션 알고리즘